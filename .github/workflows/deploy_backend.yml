name: Deploy Backend to AWS Elastic Beanstalk

on:
  push:
    branches:
      - main
    paths:
      - 'devdash/backend/**'
      - '.github/workflows/deploy_backend.yml'
  
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Generate deployment package
        run: |
          mkdir -p deploy/
          
          # Copy backend files
          cp -r devdash/backend/* deploy/
          
          # Create necessary directories
          mkdir -p deploy/.ebextensions
          mkdir -p deploy/.platform/hooks/prebuild
          
          # Create a simplified environment config
          cat > deploy/.ebextensions/01_environment.config << 'EOF'
          option_settings:
            aws:elasticbeanstalk:application:environment:
              ENVIRONMENT: production
              DEBUG: false
              PYTHONPATH: /var/app
            
            aws:elasticbeanstalk:container:python:
              WSGIPath: application:application
          EOF
          
          # Create a simplified prebuild script with proper formatting
          cat > deploy/.platform/hooks/prebuild/01_get_secrets.sh << 'EOF'
          #!/bin/bash
          
          # Create .env file for environment variables
          ENV_FILE=/var/app/staging/.env
          
          # Set basic environment variables that don't require secrets
          echo "ENVIRONMENT=production" > $ENV_FILE
          echo "DEBUG=false" >> $ENV_FILE
          
          # Only attempt to get secrets if you're sure AWS CLI is available
          if command -v aws &> /dev/null; then
            # Add debugging information
            echo "AWS CLI found, attempting to retrieve secrets" >> /var/log/secrets-debug.log
            
            # Hard-code the AWS region
            AWS_REGION="ap-southeast-2"
            
            # Try to get database credentials with error handling
            DB_SECRET=$(aws secretsmanager get-secret-value --secret-id "prod/devdash/dbsecret" --region ${AWS_REGION} --query SecretString --output text 2>/var/log/aws-secret-error.log)
            
            if [ $? -eq 0 ] && [ -n "$DB_SECRET" ]; then
              # Parse the DB credentials safely
              DB_USERNAME=$(echo $DB_SECRET | jq -r '.username // empty')
              DB_PASSWORD=$(echo $DB_SECRET | jq -r '.password // empty')
              DB_ENGINE=$(echo $DB_SECRET | jq -r '.engine // "postgresql"')
              DB_HOST=$(echo $DB_SECRET | jq -r '.host // empty')
              DB_PORT=$(echo $DB_SECRET | jq -r '.port // "5432"')
              
              if [ -n "$DB_USERNAME" ] && [ -n "$DB_PASSWORD" ] && [ -n "$DB_HOST" ]; then
                # Construct the DATABASE_URL
                echo "DATABASE_URL=${DB_ENGINE}://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_USERNAME}" >> $ENV_FILE
                echo "Database URL successfully set" >> /var/log/secrets-debug.log
              else
                echo "Error: Missing required database parameters" >> /var/log/secrets-debug.log
              fi
            else
              echo "Error retrieving database secrets, using default configuration" >> /var/log/secrets-debug.log
            fi
            
            # Try to get API keys with error handling
            API_KEYS=$(aws secretsmanager get-secret-value --secret-id "prod/devdash/api-keys" --region ${AWS_REGION} --query SecretString --output text 2>>/var/log/aws-secret-error.log)
            
            if [ $? -eq 0 ] && [ -n "$API_KEYS" ]; then
              # Extract individual keys
              ANTHROPIC_KEY=$(echo $API_KEYS | jq -r '.["anthropic-api-key"] // empty')
              STACKEX_KEY=$(echo $API_KEYS | jq -r '.["stack-exchange-api-key"] // empty')
              
              if [ -n "$ANTHROPIC_KEY" ]; then
                echo "ANTHROPIC_API_KEY=$ANTHROPIC_KEY" >> $ENV_FILE
                echo "Anthropic API key successfully set" >> /var/log/secrets-debug.log
              fi
              
              if [ -n "$STACKEX_KEY" ]; then
                echo "STACK_EXCHANGE_API_KEY=$STACKEX_KEY" >> $ENV_FILE
                echo "Stack Exchange API key successfully set" >> /var/log/secrets-debug.log
              fi
            else
              echo "Error retrieving API keys" >> /var/log/secrets-debug.log
            fi
          else
            echo "AWS CLI not available, skipping secrets retrieval" >> /var/log/secrets-debug.log
          fi
          
          chmod 644 $ENV_FILE
          echo "Script completed successfully" >> /var/log/secrets-debug.log
          EOF
          
          # Ensure the script has executable permissions
          chmod +x deploy/.platform/hooks/prebuild/01_get_secrets.sh
          
          # Fix potential line ending issues in all shell scripts
          find deploy -name "*.sh" -type f -exec sed -i -e 's/\r$//' {} \;
          
          # Fix application.py for better error handling
          if [ -f "deploy/application.py" ]; then
            cp deploy/application.py deploy/application.py.bak
            cat > deploy/application.py << 'EOF'
          """
          Application entry point for AWS Elastic Beanstalk.
          """
          import os
          import sys
          
          # Add the backend directory to the path
          sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
          
          # Import the FastAPI application
          try:
              from app.main import app
              print("Successfully imported app.main")
          except Exception as e:
              # Log the import error
              with open('/var/log/app_import_error.log', 'a') as f:
                  f.write(f"Error importing app.main: {str(e)}\n")
                  f.write(f"Python path: {sys.path}\n")
                  f.write(f"Current directory: {os.getcwd()}\n")
                  f.write(f"Directory contents: {os.listdir()}\n")
              raise
          
          # Create a WSGI handler with proper error handling
          def application(environ, start_response):
              # Handle CONTENT_LENGTH properly
              try:
                  if 'CONTENT_LENGTH' not in environ or environ['CONTENT_LENGTH'] == '':
                      environ['CONTENT_LENGTH'] = '0'
              except Exception as e:
                  environ['CONTENT_LENGTH'] = '0'
                  with open('/var/log/wsgi_error.log', 'a') as f:
                      f.write(f"Error with CONTENT_LENGTH: {str(e)}\n")
              
              # Continue with the regular request handling
              try:
                  return app(environ, start_response)
              except Exception as e:
                  # Log any application errors
                  with open('/var/log/app_error.log', 'a') as f:
                      f.write(f"Application error: {str(e)}\n")
                  # Return a basic error response
                  status = '500 Internal Server Error'
                  headers = [('Content-type', 'text/plain')]
                  start_response(status, headers)
                  return [b"Internal Server Error. Check application logs for details."]
          
          # For local development
          if __name__ == "__main__":
              import uvicorn
              uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)
          EOF
          fi
          
          # Make sure we have psycopg2-binary in requirements.txt
          if [ -f "deploy/requirements.txt" ]; then
            if ! grep -q "psycopg2-binary" deploy/requirements.txt; then
              echo "psycopg2-binary==2.9.5" >> deploy/requirements.txt
            fi
          fi
          
          # Create zip package
          cd deploy
          zip -r ../deploy.zip .
          cd ..
          
          # List the contents for verification
          echo "Deployment package contents:"
          unzip -l deploy.zip | head -20
        
      - name: Deploy to EB
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: DevDashBackend
          environment_name: DevDashBackend-env
          version_label: backend-${{ github.sha }}
          region: ${{ secrets.AWS_REGION }}
          deployment_package: deploy.zip
          wait_for_deployment: true